"""Data structures for JaxMANEnv

Author: Hikaru Asano
Affiliation: OMRON SINIC X / University of Tokyo
"""
from __future__ import annotations

from typing import NamedTuple, Optional, Tuple

import chex
import jax.numpy as jnp
import numpy as np
from chex import Array

from ..core import AgentState
from ..obstacle import ObstacleMap


class TrialInfo(NamedTuple):
    """Local planning information shared among agents and changed during each trial"""

    timesteps: Array = jnp.array(0)
    agent_collided: Array = None
    item_collided: Array = None
    solved: Array = None
    solved_time: Array = None
    # solved_time: Array = None
    timeout: Array = None
    delivery_rate: Array = None
    agent_crash_rate: Array = None
    item_crash_rate: Array = None
    sum_of_cost: Array = None
    makespan: Array = None
    is_success: Array = None
    # is_success: Array = jnp.array(0).astype(bool)

    @classmethod
    def reset(self, num_agents: int, num_items: int):
        return self(
            timesteps=jnp.array(0),
            agent_collided=jnp.zeros(num_agents).astype(bool),
            item_collided=jnp.zeros(num_items).astype(bool),
            solved=jnp.zeros(num_items).astype(bool),
            solved_time=jnp.ones(num_items) * jnp.inf,
            timeout=False,
            delivery_rate=jnp.array(0),
            agent_crash_rate=jnp.array(0),
            item_crash_rate=jnp.array(0),
            sum_of_cost=jnp.array(0),
            makespan=jnp.array(0),
            is_success=jnp.array(0).astype(bool),
        )


class TaskInfo(NamedTuple):
    """Local planning information shared among agents and fixed during each trial"""

    starts: Array
    start_rots: Array
    item_starts: Array
    item_goals: Array
    obs: ObstacleMap

    def cat(self, as_numpy=False) -> Array:
        ret = jnp.hstack((self.starts, self.start_rots, self.goals))
        if as_numpy:
            ret = np.array(ret)
        return ret


class State(NamedTuple):
    """
    Args:
        pos (Array): [n_agents, 2]-array
        rot (Array): [n_agents, 1]-array
        vel (Array): [n_agents, 1]-array
        ang (Array): [n_agents, 1]-array
    """

    agent_state: AgentState = None
    load_item_id: Array = None
    item_pos: Array = None

    def cat(self, as_numpy=False) -> Array:
        # TODO don't ignore load item id
        ret = jnp.hstack(
            (
                self.agent_state.pos,
                self.agent_state.rot,
                self.agent_state.vel,
                self.agent_state.ang,
                jnp.expand_dims(self.load_item_id, -1),
            )
        )
        item_pos = self.item_pos
        if as_numpy:
            ret = np.array(ret)
            item_pos = np.array(item_pos)
        return ret, item_pos

    @classmethod
    def from_array(self, agent_array: Array, item_array):
        agent_state = AgentState.from_array(agent_array[:, :-1])
        load_item_id = agent_array[:, -1]
        item_pos = item_array
        return State(agent_state, load_item_id, item_pos)


class AgentObservation(NamedTuple):
    """
    An observation generated by states, env_info, and task_info.
    Args:
        state (AgentState): Agents' states
        goal (Array): Agents' goal positions
        scans (Array): [n_agents, num_scans] array.
        planner_act (Array): DWA planner action suggestion
    """

    agent_state: AgentState
    obs_scans: Array
    is_hold_item: Array
    relative_positions: Array
    intentions: Array
    item_info: Array
    masks: Array
    item_masks: Array
    item_goals: Array

    def cat(self, as_numpy=False) -> Array:
        """
        concatenate agent observations into a single array

        Args:
            as_numpy (bool, optional): whether to transform output to numpy array. Defaults to False (i.e., outputs jax array).

        Returns:
            Array: concatenated observation
        """
        ret_state = self.agent_state.cat()
        ret = jnp.hstack(
            (
                ret_state,
                self.obs_scans,
                self.is_hold_item,
                self.item_goals,
            )
        )

        num_agents = ret.shape[0]

        # agent communication
        comm = jnp.concatenate((self.relative_positions, self.intentions), axis=-1)
        ret = jnp.hstack((ret, comm.reshape([num_agents, -1]), self.masks))

        # item communication
        ret = jnp.hstack(
            (ret, self.item_info.reshape([num_agents, -1]), self.item_masks)
        )

        if as_numpy:
            ret = np.array(ret)
        return ret

    def split_observation(self) -> Tuple[Array, Array, Array]:
        """split agent observation into base_observation, communication, communication mask, item information, item mask

        Returns:
            Tuple[Array, Array, Array]: base_observation, communication, communication_mask
        """
        ret_state = self.agent_state.cat()
        obs = jnp.hstack(
            (
                ret_state,
                self.obs_scans,
                self.is_hold_item,
                self.item_goals,
            )
        )
        comm = jnp.concatenate((self.relative_positions, self.intentions), axis=-1)
        mask = self.masks

        item_pos = self.item_info
        item_mask = self.item_masks

        return obs, comm, mask, item_pos, item_mask

    def is_valid(self) -> None:
        # (n_agents, 2)
        chex.assert_rank(self.goals, 2)
